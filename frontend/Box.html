<!DOCTYPE html>
<html lang="fa">
<head>
<meta charset="UTF-8" />
<title>Stable Cube Particles — Fixed</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<style>
  * { margin:0; padding:0; box-sizing:border-box; }
  html,body { height:100%; }
  body { background: radial-gradient(circle at center, #0b0b0b, #000); overflow:hidden; font-family: sans-serif; }
  canvas { display:block; }
  .info { position: absolute; top:10px; left:10px; color: #fff8; font-size:13px; backdrop-filter: blur(4px); padding:6px 8px; border-radius:6px; }
</style>
</head>
<body>

<script>

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = 6.2;

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
document.body.appendChild(renderer.domElement);


const outerSize = 2.0;
const innerSize = outerSize * 0.75;

const outerCube = new THREE.LineSegments(
  new THREE.EdgesGeometry(new THREE.BoxGeometry(outerSize, outerSize, outerSize)),
  new THREE.LineBasicMaterial({color:0xffffff, opacity:0.15, transparent:true})
);


const innerCube = new THREE.LineSegments(
  new THREE.EdgesGeometry(new THREE.BoxGeometry(innerSize, innerSize, innerSize)),
  new THREE.LineBasicMaterial({color:0xffffff, opacity:0.35, transparent:true})
);



const particleMaterial = new THREE.PointsMaterial({ color:0xffffff, size:0.035, sizeAttenuation:true, transparent:true, opacity:0.95 });
const baseParticleCount = 2500; // تعداد پایه ذرات   
const particleCount = Math.floor(baseParticleCount * 1.3);

const positions = new Float32Array(particleCount * 3);
const velocities = new Float32Array(particleCount * 3);

const minLimit = innerSize/2;
const maxLimit = outerSize/2;


function randomPositionInShell() {
  while(true){
    const x = (Math.random()*2 - 1) * maxLimit;
    const y = (Math.random()*2 - 1) * maxLimit;
    const z = (Math.random()*2 - 1) * maxLimit;

    if(Math.abs(x) < minLimit && Math.abs(y) < minLimit && Math.abs(z) < minLimit) continue;

    return [x,y,z];
  }
}


const introDuration = 1.7 * 1000; // ms
const startTime = performance.now();

for(let i=0;i<particleCount;i++){

  positions[i*3 + 0] = (Math.random()*2 - 1) * 4.0;
  positions[i*3 + 1] = (Math.random()*2 - 1) * 4.0;
  positions[i*3 + 2] = (Math.random()*2 - 1) * 4.0;


  velocities[i*3 + 0] = 0;
  velocities[i*3 + 1] = 0;
  velocities[i*3 + 2] = 0;
}


const targetPositions = new Float32Array(particleCount * 3);
for(let i=0;i<particleCount;i++){
  const p = randomPositionInShell();
  targetPositions[i*3 + 0] = p[0];
  targetPositions[i*3 + 1] = p[1];
  targetPositions[i*3 + 2] = p[2];
}

const geometry = new THREE.BufferGeometry();
geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
const particles = new THREE.Points(geometry, particleMaterial);
scene.add(particles);


const motionIntensity = 0.05; //  عدد اصلی کنترل حرکت

const jitter = 0.0009 * motionIntensity;    
const damping = 1 - (1 - 0.997) * motionIntensity;
const velocityCap = 0.05 * motionIntensity;   

function capVelocity(ix, iy, iz) {
  const vx = velocities[ix];
  const vy = velocities[iy];
  const vz = velocities[iz];
  const mag2 = vx*vx + vy*vy + vz*vz;
  if(mag2 > velocityCap*velocityCap){
    const mag = Math.sqrt(mag2);
    const s = velocityCap / mag;
    velocities[ix] *= s;
    velocities[iy] *= s;
    velocities[iz] *= s;
  }
}

function resolveInnerCollision(i){

  const px = positions[i*3 + 0];
  const py = positions[i*3 + 1];
  const pz = positions[i*3 + 2];

  const ax = Math.abs(px);
  const ay = Math.abs(py);
  const az = Math.abs(pz);


  if(ax < minLimit && ay < minLimit && az < minLimit){

    const penX = minLimit - ax;
    const penY = minLimit - ay;
    const penZ = minLimit - az;


    if(penX >= penY && penX >= penZ){

      const sign = px >= 0 ? 1 : -1;
      positions[i*3 + 0] = sign * minLimit;
      velocities[i*3 + 0] *= -1; 
 
      velocities[i*3 + 1] += (Math.random()-0.5) * 0.006;
      velocities[i*3 + 2] += (Math.random()-0.5) * 0.006;
    } else if(penY >= penX && penY >= penZ){
      const sign = py >= 0 ? 1 : -1;
      positions[i*3 + 1] = sign * minLimit;
      velocities[i*3 + 1] *= -1;
      velocities[i*3 + 0] += (Math.random()-0.5) * 0.006;
      velocities[i*3 + 2] += (Math.random()-0.5) * 0.006;
    } else {
      const sign = pz >= 0 ? 1 : -1;
      positions[i*3 + 2] = sign * minLimit;
      velocities[i*3 + 2] *= -1;
      velocities[i*3 + 0] += (Math.random()-0.5) * 0.006;
      velocities[i*3 + 1] += (Math.random()-0.5) * 0.006;
    }
  }
}

function animate(){
  const now = performance.now();
  const introProgress = Math.min((now - startTime) / introDuration, 1);
  requestAnimationFrame(animate);

  const pos = geometry.attributes.position.array;

  for(let i=0;i<particleCount;i++){
    const ix = i*3, iy = ix+1, iz = ix+2;


    if(introProgress < 1){
      const ease = introProgress * introProgress * (3 - 2 * introProgress); // smoothstep
      pos[ix] += (targetPositions[ix] - pos[ix]) * 0.08 * ease;
      pos[iy] += (targetPositions[iy] - pos[iy]) * 0.08 * ease;
      pos[iz] += (targetPositions[iz] - pos[iz]) * 0.08 * ease;
      continue;
    }


    velocities[ix] += (Math.random()-0.5) * jitter;
    velocities[iy] += (Math.random()-0.5) * jitter;
    velocities[iz] += (Math.random()-0.5) * jitter;

    pos[ix] += velocities[ix];
    pos[iy] += velocities[iy];
    pos[iz] += velocities[iz];

    if(pos[ix] > maxLimit){ pos[ix] = maxLimit; velocities[ix] *= -1; }
    if(pos[ix] < -maxLimit){ pos[ix] = -maxLimit; velocities[ix] *= -1; }
    if(pos[iy] > maxLimit){ pos[iy] = maxLimit; velocities[iy] *= -1; }
    if(pos[iy] < -maxLimit){ pos[iy] = -maxLimit; velocities[iy] *= -1; }
    if(pos[iz] > maxLimit){ pos[iz] = maxLimit; velocities[iz] *= -1; }
    if(pos[iz] < -maxLimit){ pos[iz] = -maxLimit; velocities[iz] *= -1; }

    resolveInnerCollision(i);

    velocities[ix] *= damping;
    velocities[iy] *= damping;
    velocities[iz] *= damping;

    capVelocity(ix, iy, iz);
  }

  geometry.attributes.position.needsUpdate = true;

  particles.rotation.x += 0.0014;
  particles.rotation.y += 0.0016;

  renderer.render(scene, camera);
}

animate();


window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
